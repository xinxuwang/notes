## InnoDB 索引实现
* 表数据文件本身按B+tree(便于范围查询)组织成主索引(聚集索引)文件。InnoDB每张表都应该有自增的primary key，如果没有，数据库隐藏创建。
* 主键单调递增，避免频繁调整树结构，对于新插入数据append使树紧凑。写满一页再开辟下一页。
* 辅助索引(其他字段上的索引)，先查找辅助索引找到列信息其中包括了主索引，再查询主索引得到行数据信息。如果所查的列数据都在辅助索引上，可以不用回表，否则需要回表获得。
* 不建议使用过长的字段作为主键，因为所有的辅助索引都引用主索引，过长的主索引会让辅助索引变得过大。
## 联合索引最左原则
* 联合索引有三个索引字段(A,B,C)。相当于建立了A，AB，ABC三个索引(实际上是一个B+tree)。在对A排序的基础上再对B排序(A值相等的情况下B也是有序的)。
* 单看B并不是有序的，所以有最左匹配原则。
* (A，，)     ---会使用索引  
* (A，B，)    ---会使用索引
* (A，B，C)   ---会使用索引
* (，B，C)    ---不会使用索引
* (，，C)     ---不会使用索引
* (A，，C)    ---不会使用索引
* mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
* 复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的，所以在设计表时，最好不要允许NULL。
## 索引匹配
* Index range 先确认索引的起止范围
* Index Filter 索引过滤
* Table Filter 表过滤
* 全值匹配(A=?,B=?)
* 匹配左边的列(B=?走全表匹配)
* 匹配列前缀(As%--索引，%As,%As%--全表)
* 匹配范围值(A>?andA<?--索引，A>?andA<? and B<?--A走索引，找到A范围后，再逐条过滤B)
* 精确匹配某一列并范围匹配另一列(A=? and B >? --索引)
* 排序(orderby A,B--索引，数据少时优化为全表。orderby B,A--不走索引。A=? orderby B 可以索引)
## 联合索引时的列选择
* 经常用的列优先(最左匹配原则)
* 离散度高的列优先(离散度高原则)
* 宽度小的列优先(最少空间原则)
## Null
* 在字段不允许为null的情况下，查询is null或is not null都不走索引
* 在字段允许为null的情况下，查询is null或is not null可以走索引
