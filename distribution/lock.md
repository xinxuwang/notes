## 分布式锁
* 分布式环境下，一个方法在同一时间只能被一台机器的一个线程执行
* 高可用的获取锁和释放锁
* 高性能的获取锁和释放锁
* 可重入特性
* 需要锁失效机制，防止死锁
* 非阻塞，没有获取到锁将直接返回获取失败
## 悲观锁和乐观锁
* 悲观锁认为每次操作都会有其他线程修改临界区，所以在每次操作时都将进行加锁解锁操作，开销大
* 乐观锁认为每次操作其他线程不会修改临界区，操作时不加锁，再修改临界区时候判断是否被修改了，CAS
## Redis
* 加锁  
1.使用lua脚本进行get和set操作  
2.hset myLock 8743c9c0-0795-4907-87fd-6c719a6b4586:1 1  
3.pexpire myLock 30000   
* 锁互斥  
1.加锁时，发现myLock锁已经存在
2.判断myLock的值不是当前线程  
3.返回锁的超时时间，线程等待超时再去加锁
* watch dog自动延期，每10s检查一下，如果线程还拥有锁，则将锁的超时时间延长
* 可重入  
1.加锁发现锁存在  
2.判断值是当前线程  
3.对值+1,myLock 8743c9c0-0795-4907-87fd-6c719a6b4586:1 2
* 释放锁
1.判断锁是否存在  
2.是当前线程号，对值-1，如果减成0则删除锁
* 缺点是当主，被切换时在同步期间容易导致脏数据
## Mysql (不推荐)
## Etcd
[参考](https://www.jianshu.com/p/3be460bf9e0f)
##### 机制
* Lease:k-v超时时间，支持续约即KeepAlive
* Revision:每个key都有(全局唯一)，每进行一次事务全局+1，通过比较revision可以知道写操作顺序
* 多个线程抢锁，根据revision大小依次获取锁，避免惊群现象，实现公平锁
* Prefix，前缀机制(目录机制)，可以根据目录获取该目录下所有的key和属性(key,value,revision等)
* Watch，监听机制，Watch目录或key变化时收到通知
##### 过程
* 加锁  
1.链接etcd,/etc/lock为前缀创建全局唯一key，第一个线程创建为/etc/lock/UUID1,第二个为/etc/lock/UUID2  
2.客户端将自己全局唯一的key写入etcd,put操作
3.客户端以前缀/etc/lock读取k-v表，判断自己的key的Revision是否是列表中最小的，如果是则获取锁   
4.如果不是最小的，watch前一个Revision比自己小的key的删除事件，删除或超期，则自己获取锁  
5.获得锁的线程发送心跳消息
* 锁互斥  
1.相当于有一个锁等待队列，每一个线程监听前一个线程的删除事件
* 可重入  
1.加锁发现锁存在，并且是当前的leaseID
* 释放锁  
1.删除key
