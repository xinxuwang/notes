## 过期策略
* 定时过期，为每个key设置过期时间，创建一个定时器，到期key自动删除。内存友好，占用cpu，影响吞吐
* 惰性过期，只有在访问一个key时，才去判断是否过期，cpu友好，极端情况大量过期key没有访问，得不到删除
* 定期过期，一定时间，扫描一定数量的key，并清楚其中过期的key，是一个折中方案Redis 默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。
1. 从过期字典中随机 20 个 key；
2. 删除这 20 个 key 中已经过期的 key；
3. 如果过期的 key 比率超过 1/4，那就重复步骤 1；
* Redis采用惰性删除和定期删除
## 内存淘汰策略
* 惰性和定期删除都会存在key没有被删除的情况，导致内存超过最大值，所以需要内存淘汰
* noeviction内存超过限制直接返回错误，即不删除
* allkeys-lru加入键的时候，如果过限，通过LRU算法从所有key中驱逐最久没有使用的键
* volatile-lru加入键的时候，首先从设置了过期时间的集合中驱逐最久没有使用的键
* allkeys-random从所有key随机删除
* volatile-random从过期集合中随机删除
* volatile-ttl从配置过期时间的集合中删除马上要过期的key
* volatile-lfu从过期时间的集合中驱逐使用频率最少的key
* allkey-lfu从所有键中驱逐使用频率最少的key
## 通用的LRU
* 新增key value添加到链表结尾，淘汰时淘汰队列前
* 修改，访问时，移动到队尾
## LFU
````
A~~A~~A~~A~~A~~A~~A~~A~~A~~A~~~|
B~~~~~B~~~~~B~~~~~B~~~~~~~~~~~~B|
````
* 上图应该淘汰B更加合理
* 在LRU基础上再对频率做限制
