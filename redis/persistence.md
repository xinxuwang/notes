## RDB
* 周期性的持久化，压缩的二进制文件，适合备份和全量复制，恢复比AOF快
* 数据完整性和一致性不高
* 是快照文件，只能恢复到最后一次
* 备份时会使用内存，fork一个子进程，子进程写临时文件再替换之前的备份文件，所以内存膨胀为两倍
####手动触发和COW
* SAVE直接调用rdbSave,会阻塞主进程，无法提供服务
* BGSAVE则是fork一个子进程，子进程调用rdbSave，处理完后想主进程发信号。此期间主进程可以继续提供服务
* Copy on write备份的是开始时刻内存数据，只复制被修改的内存数据，不是全部数据。cow时如果大量写可能导致分页错误
## AOF
* 类似于mysql的binlog，写入操作以append-only写入日志文件
* AOF通过后台线程一秒一次fsync
* AOF文件大，恢复速度慢
####整体流程
* 命令实时写入，不同级别可能有1s的损失，先写入buffer再fsync到文件
* 重写aof文件以减少文件大小，可以手动或自动触发(BGREWRITEAOF)。fork子进程
* 重写期间主进程依然可用，为了保证完整性，依然要写入旧的aof
* 重写是把当前内存生成命令写入不需要分析旧的aof
* 无论rdb还是aof都是写入临时文件再rename成新的
## fork的建议
* 降低fork频率，比如手动来rdb，aof重写
* 设置最大内存，避免fork执行太长
## 恢复
* 启动时先检查aof是否存在(数据更加完整)，不存在则使用RDB恢复
* 可以先用rdb镜像恢复，再使用aof补全缺失的数据
