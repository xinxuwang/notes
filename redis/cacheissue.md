## 缓存雪崩
* Redis中大批量的key失效，导致请求打到Mysql中，Mysql承受不住崩溃
* 缓存数据过期时间加上随机值，避免同一时间大量key过期
* 将热点数据均匀的分布到不同实例上
* 热点数据不过期
## 缓存穿透
* 缓存和数据库中都没有请求数据，一直请求导致数据库压力大
* 增加后段鉴权，IP访问次数
* 缓存和数据库中都没有的数据，也可以写入缓存key-null，并设置超时时间
* Bloom Filter
## 缓存击穿
* 大并发集中对一个热点进行访问，当这个key过期后，击穿缓存，打到数据库上
* 热点数据不过期，互斥锁
## 双写一致(一定是最终一致的)
* 理论上给缓存设置超时，写操作以数据库为准。那么就能保证最终一致性
#### 先更新数据库，再更新缓存
* 普遍反对，线程不安全，容易脏读
* A写入数据库数据1，B写入数据库数据2，B先更新缓存为2，A再更新缓存为1，导致不一致
#### 先删除缓存，再更新数据库
* 也会导致不一致
* A写操作，删除缓存。B读操作，没有命中缓存，从数据库中拿到旧值，更新缓存。A再将新值写到数据库中
* 如果没有超时，那么读出来的都是旧数据
* 采用延迟双删策略 
````
public void write(String key,Object data){
        redis.delKey(key);
        db.updateData(data);
        Thread.sleep(1000);
        redis.delKey(key);
    }
````
* 相当于是在程序中人为的加了超时时间，使得sleep期间的脏读快速过期
* 如果是读写分离还需要考虑同步的时间
* 如果第二次删除失败则退化为一次删除
#### 先更新数据库，再删除缓存
* 也会不一致，虽然概率小
* 刚好缓存失效，A查询数据库得到旧值，此时B更新数据库写入新值，B删除缓存
* 请求A将查询到的旧值写入缓存
* 当B写数据库比A读数据库更快的时候出现不一致
* 一定要解决的话，缓存失效时间和延迟删除
#### 删除缓存失败，如何解决
* 使用重试删除缓存
* 订阅mysql的binlog日志(canal)，提取需要的删除的key，非业务代码放入消息队列
* 非业务代码提取消息队列key，重新尝试删除